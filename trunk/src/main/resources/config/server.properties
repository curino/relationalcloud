###
# Shepherd properties file
###

### Logging

# log to stdout and to file?
log.split=true

### Write-Ahead logging

# delete contents of database xactions tables on start
# (obviously, don't set this if shepherd is restarting after a crash!)
cleanstart=true

### Interface

# port to listen on
port=7777

### Replicas

# database database
dbprops=databases.properties

# dbs specifies which databases to use
# primary defaults to first entry in the list
primary=lmysql

# database connection isolation mode
# readuncommitted, readcommitted, serializable
database.isolation= serializable

# initialize database with xactions tables?
database.fullinit= true

# number of execution threads
# number of concurrent connections to each database (DB level concurrency; xactions at a time)
replica.concurrency=20

# mode to run replicas in  (class name)
# hrdb.simple.CBSTExec          - commit barrier scheduling
# hrdb.simple.FaultTolerantTExec - CBS, with fault tolerance
# hrdb.simple.CBSNoVoteExec     - cbs, but with no voting; primary will lead secondaries
# hrdb.simple.EarlyPrimaryTExec - cbs, but primary commits when commit arrives, pre agreement
# hrdb.simple.ProntoTExec       - stmts to secondaries after primary finished executing
# hrdb.simple.TableLockingTExec - use explicit or implicit shepherd-level locking for transaction ordering
# hrdb.simple.SITExec           - snapshot barrier scheduling (use with postgres and oracle)
# hrdb.simple.SerialTExec       - serialized
replica.mode=hrdb.simple.FaultTolerantTExec

# use db connectivity layer
# dbc    - use hrdb.database.DBConnection
# actual - use straight JDBC
replica.connection=actual

# allows DBs to use group commit
# technically unsafe unless using shim
cbs.dbgc=true

# have coordinator use group commit
cbs.coordgc=true

# log transaction execution times
cbs.logtimes=false

# yield just before commit (should lower performance)
cbs.commityield=false

# table level locking
autolocktables=false

# abort Ts when lock wait queues reach this size
locking.maxdepth=0
locking.timeout=0

### Timeouts

# polling interval in ms
timeout.interval=1000

# time in ms since last stmt exec before declaring a replica stalled
timeout.replicastall=5000

### Flags

# print debugging info
#debug=true

# verbose xaction info
printinfo=false

# print barrier status information
printbarriers=true

## agreement, pick at most one

# primary is always right, primary will diverge from replicas (doesn't have to wait)
#force=true

# replicas always agree, primary will not diverge (needs f secondaries to move forward)
#match=true

## concurrency, pick at most one

# force serial execution of transactions
#
#serial=true

# serialize transactions on secondaries
#serial_secondaries=true

## optimizations

# allow read-only transactions to pass each other
#readonly=true

## repair

# perform repair when replica faults
#repair=true

### PassThru

# % of transaction secondaries have not executed when primary completes
# from 0..1, where 0 is complete pipelining and 1 is no pipelining
passthru.commitoverhead=0.0

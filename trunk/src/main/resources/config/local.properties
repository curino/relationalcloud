
###################################################
#                                                 #  
#     relationalcloud.com configuration script    #
#                                                 # 
###################################################


######### DBMS connection configuration ###########


# Uncomment and configure the DB connection
driver=com.mysql.jdbc.Driver
conn=jdbc:mysql://localhost:3306/
schema=baloon
queryLogSchema=tpcc2
informationSchema=information_schema
user=root
password=

########### SCHEMA PREPARATION #####################
metaSchemaFile=./meta_schema.sql

########### QUERY_LOG LOADER #####################
# this parameter control how many transactions will be processed
# this limits both the query load and the transactions2transactionlog phase
inserter.nconns=10

########### TRANSACTIONS TO TRANSACTIONLOG ####### 
# this controls the number of transactions that will be processed 
#(i.e., for which we compute read/write sets) from the transactions 
Transactions2TransactionLog.numTransactionsToProcess=1000
# the file containing the sql for the extra tables we need
BlanketFilter.minTableSize=30
# NOTE: setting mincount and maxcount to the same value transform the filter to a 
# hard threshold, and does not compute ratios with the table size
# this is useful to avoid cases in which the joins without WHERE clause are too slow
BlanketFilter.maxCount=100
BlanketFilter.minCount=100
BlanketFilter.threshold=0.1

################ TRANSACTIONLOG SAMPLING ######### 
# transaction-level sampling
# ATTENTION the resulting number of transactions must match the numb_trans_to_process
SampleTransactionlog.trainingSetSize=800
SampleTransactionlog.testSetSize=200

#tuple=level sampling
SampleTransactionlog.minTuplesPerTable=20
SampleTransactionlog.samplingRatio=0.2

############# SCHEMA EXTENSIONS ##################
viewPrefix=relcloud_
#initial table holding transactions
txnLogTable=metarelcloud_txn_log
# initial table holding the large read/write sets for transaction 
accessLogTable=metarelcloud_access_log
# the table from which we do tuple-sampling
trainingAccessLogTable=metarelcloud_training_access_log
# the table used for testing the final result of partitioning
testingAccessLogTable=metarelcloud_testing_access_log
# the table on which we run the partitioning
sampledAccessLogTable=metarelcloud_sampledtraining_access_log
partitioningTable=metarelcloud_partitioning
#this table is created temporarily to compute the replication column
tmpRepTable=metarelcloud_tmp_rep

# the following tables are used to store the graph representation and its metadata
graphTable=metarelcloud_graph
repGraphTable=metarelcloud_rep_graph
graphSupportTable=metarelcloud_graph_support
repGraphSupportTable=	
generalQueryLog=metarelcloud_general_query_log

# this are the columns used in the access_log tables to store partitioning strategies
graphPartitionCol=graph_partition
replicatedPartitionCol=replicated_partition
explainedPartitionCol=justified_partition
hashPartitionCol=hash_partition
manualPartitionCol=manual_partition

############### METIS FILES #######################                                  
# this are the configuration parameters used to drive the METIS graph partitioner             
graphFile=/mypath/graph.txt
numPartitions=2
useWeights=false
partitioningMethod=repGraph

############ REPLICATION PREDICTION ##############
#controls how balanced should be the use of a tuple across multiple partitions before we use replication. 
maxReplicationSkew=0.4
#the id assigned to the virtual partition representing replication, must be higher than numPartitions
repPartitionId=2

############ EXPLANATION PARAMETERS ##############
# this are the parameters used to configure the Weka-based explanation phase
dbPropertyFile=../../resources/config/WekaHelper.props
Explanation.populateJustificationColumn=true
Explanation.numTxnsToExtractTemplates=1000
Explanation.j48SamplingThreshold=1000
Explanation.j48PruningConfidence=0.1
